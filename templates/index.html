<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OllamaBench Dashboard - Optimiert</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; 
        }
        .chart-container {
            position: relative;
            height: 380px; 
            width: 100%;
            max-width: 600px; 
            margin: auto;
        }
        canvas {
            display: block;
            box-sizing: border-box;
            height: 100% !important;
            width: 100% !important;
        }
        .table-container {
            overflow-x: auto;
            max-height: 450px; 
            border-radius: 0.5rem; 
            border: 1px solid #e5e7eb; 
        }
        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #f9fafb; 
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 32px; 
            height: 32px;
            border-radius: 50%;
            border-left-color: #3b82f6; 
            animation: spin 1s linear infinite; 
            margin: 5px auto;
            display: inline-block;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .action-button {
            background-color: #3b82f6; 
            color: white;
            padding: 12px 24px; 
            border: none;
            border-radius: 0.5rem; 
            font-weight: 600; 
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            gap: 10px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); 
        }
        .action-button:hover {
            background-color: #2563eb; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); 
        }
        .action-button:disabled {
            background-color: #9ca3af; 
            cursor: not-allowed;
            box-shadow: none;
        }
        .action-button .loading-spinner {
            width: 18px; 
            height: 18px;
            border-width: 3px;
            margin: 0;
        }
        .status-message {
            margin-top: 16px; 
            padding: 12px 18px; 
            border-radius: 0.5rem; 
            font-size: 0.95em; 
            font-weight: 500;
            text-align: center;
            transition: opacity 0.5s ease-in-out, transform 0.3s ease-in-out;
            border-width: 1px;
            border-style: solid;
        }
        .status-success { background-color: #ecfdf5; color: #065f46; border-color: #6ee7b7; } 
        .status-error   { background-color: #fff1f2; color: #9f1239; border-color: #fecaca; } 
        .status-warning { background-color: #fffbeb; color: #92400e; border-color: #fde68a; } 
        .status-info    { background-color: #eff6ff; color: #1e40af; border-color: #bfdbfe; } 
        .status-loading {
             background-color: #eff6ff; color: #1e40af; border-color: #bfdbfe;
             display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .status-loading .loading-spinner { width: 18px; height: 18px; border-width: 3px; margin: 0; }

        .category-select {
            padding: 10px 14px; 
            border-radius: 0.375rem; 
            border: 1px solid #d1d5db; 
            background-color: white;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .category-select:focus {
            outline: none;
            border-color: #3b82f6; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); 
        }
        .hidden { display: none !important; } 

        .sticky-header th {
            position: sticky;
            top: 0;
            background-color: #f9fafb; 
            z-index: 10;
            white-space: nowrap;
            border-bottom: 2px solid #e5e7eb; 
            font-weight: 600; 
            color: #374151; 
        }
        .detailed-ratings-table td { 
            white-space: nowrap;
            /* Tooltip styling for better readability if needed, but title attribute is native */
        }
        .detailed-ratings-table td[title]:hover {
            cursor: help; /* Indicate that there's a tooltip */
        }


        /* Card styling */
        .dashboard-card {
            background-color: white;
            border-radius: 0.75rem; 
            padding: 20px 24px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05); 
            transition: box-shadow 0.3s ease-in-out;
        }
        .dashboard-card:hover {
             box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -4px rgba(0, 0, 0, 0.07); 
        }
        .card-title {
            font-size: 1.25rem; 
            font-weight: 700; 
            color: #1f2937; 
            margin-bottom: 1rem; 
        }
        .no-data-message {
            text-align: center;
            color: #6b7280; 
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f9fafb; 
            border-radius: 0.375rem; 
            font-style: italic;
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">
    <div class="max-w-screen-2xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-extrabold text-slate-800">
                OllamaBench Dashboard
            </h1>
            <p class="text-slate-600 mt-2 text-lg">Modell-Performance auf einen Blick</p>
        </header>

        <div class="mb-8 p-6 dashboard-card text-center">
            <button id="run-eval-button" class="action-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"> <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15.91 11.672a.375.375 0 0 1 0 .656l-5.603 3.113a.375.375 0 0 1-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112Z" />
                </svg>
                <span id="run-eval-button-text">Starte {{ COMPARISONS_PER_RUN }} Vergleiche</span>
                <div class="loading-spinner hidden"></div>
            </button>
            <div id="eval-status" class="status-message status-info mt-5" style="opacity: 1;">Prüfe Status...</div>
        </div>

        <div id="loading-indicator" class="text-center my-12">
            <div class="loading-spinner" style="width: 48px; height: 48px; border-width: 5px;"></div>
            <p class="text-slate-600 mt-3 text-lg font-medium">Lade Dashboard-Daten...</p>
        </div>

        <div id="dashboard-content" class="hidden">
            <div class="dashboard-card mb-8">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-5">
                    <h2 class="card-title">Gesamtranking der Modelle</h2>
                    <span class="text-sm text-slate-500 mt-2 sm:mt-0">Letzte Aktualisierung: <span id="data-timestamp" class="font-medium">N/A</span></span>
                </div>
                <div class="table-container">
                    <table class="min-w-full divide-y divide-slate-200">
                        <thead class="sticky-header">
                            <tr>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Rang</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Modell</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Beste Kategorie</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Höchstes ELO</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Ø ELO</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Vergleiche</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Siege</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Niederl.</th>
                                <th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Unentsch.</th>
                            </tr>
                        </thead>
                        <tbody id="overall-rankings-table-body" class="bg-white divide-y divide-slate-100">
                            <tr><td colspan="9" class="text-center py-6 text-slate-500">Lade Rankings...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                 <div class="dashboard-card flex flex-col items-center">
                    <div class="flex flex-col sm:flex-row items-center justify-between w-full mb-5">
                         <h2 class="card-title text-center sm:text-left">ELO-Ratings nach Kategorie</h2>
                         <select id="category-select-bar" class="category-select mt-3 sm:mt-0 sm:ml-auto">
                             <option value="">Lade...</option>
                         </select>
                    </div>
                    <div class="chart-container">
                        <canvas id="barChart"></canvas>
                         <p id="bar-chart-no-data" class="no-data-message hidden">Keine Daten für diese Kategorie verfügbar.</p>
                    </div>
                </div>
                 <div class="dashboard-card flex flex-col items-center">
                     <div class="flex items-center justify-center w-full mb-5">
                         <h2 class="card-title text-center">Modellvergleich (Radar)</h2>
                    </div>
                     <div class="chart-container">
                        <canvas id="radarChart"></canvas>
                        <p id="radar-chart-no-data" class="no-data-message hidden">Nicht genügend Daten (mind. 1 Modell & 3 Kategorien) für Radar-Diagramm.</p>
                    </div>
                </div>
            </div>

            <div class="dashboard-card mt-8">
                <h2 class="card-title mb-5">Detaillierte Ratings pro Kategorie</h2>
                <div class="table-container">
                    <table class="min-w-full divide-y divide-slate-200 detailed-ratings-table">
                        <thead id="detailed-ratings-thead" class="sticky-header">
                            </thead>
                        <tbody id="detailed-ratings-tbody" class="bg-white divide-y divide-slate-100">
                             <tr><td colspan="1" class="text-center py-6 text-slate-500">Lade detaillierte Ratings...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- JavaScript-Code ---
        console.log("Script block started."); 

        // API Endpunkte
        const API_INITIAL_RESULTS_URL = '/api/results';
        const API_RESULTS_STREAM_URL = '/stream';
        const API_RUN_EVAL_URL = '/api/run_evaluation';
        const API_EVAL_STATUS_URL = '/api/evaluation_status';

        const COMPARISONS_PER_RUN_JS = parseInt("{{ COMPARISONS_PER_RUN }}", 10) || 1;
        console.log("COMPARISONS_PER_RUN_JS:", COMPARISONS_PER_RUN_JS);

        let barChartInstance = null;
        let radarChartInstance = null;
        let currentModelsData = {};
        let availableCategories = [];
        let currentTimestamp = null;
        let eventSource = null;
        const ALL_CATEGORIES_KEY = "__all__"; 

        function generateColors(count) {
            const colors = [];
            const baseHues = [210, 350, 140, 50, 270, 20, 320, 180, 240, 90];
            const saturation = 75; 
            const lightness = 55;  
            for (let i = 0; i < count; i++) {
                const hue = baseHues[i % baseHues.length] + (Math.floor(i / baseHues.length) * 20); 
                colors.push({
                    fill: `hsla(${hue % 360}, ${saturation}%, ${lightness + 10}%, 0.45)`,
                    stroke: `hsla(${hue % 360}, ${saturation}%, ${lightness - 10}%, 1)`
                });
            }
            return colors;
        }

        function formatTimestamp(isoTimestamp) {
            if (!isoTimestamp) return 'N/A';
            try {
                const date = new Date(isoTimestamp);
                return new Intl.DateTimeFormat('de-DE', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
                }).format(date);
            } catch (e) {
                console.error("Fehler beim Formatieren des Zeitstempels:", isoTimestamp, e);
                return isoTimestamp;
            }
        }

        function capitalizeFirstLetter(string) {
            if (!string) return '';
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

         function showStatusMessage(message, type = 'info', sticky = false) {
            const statusDiv = document.getElementById('eval-status');
            if (!statusDiv) { console.error("eval-status element not found!"); return; }

            statusDiv.innerHTML = '';
            statusDiv.className = 'status-message'; 
            statusDiv.style.opacity = 1;
            statusDiv.style.transform = 'translateY(0)';

            let statusClass = '';
            switch (type) {
                case 'success': statusClass = 'status-success'; break;
                case 'error': statusClass = 'status-error'; break;
                case 'warning': statusClass = 'status-warning'; break;
                case 'loading': statusClass = 'status-loading'; break;
                default: statusClass = 'status-info'; break;
            }
            statusDiv.classList.add(statusClass);

            if (type === 'loading') {
                const spinner = document.createElement('div');
                spinner.className = 'loading-spinner';
                statusDiv.appendChild(spinner);
                statusDiv.appendChild(document.createTextNode(' ' + message));
            } else {
                statusDiv.textContent = message;
            }

            if (!sticky && type !== 'loading') {
                setTimeout(() => {
                    if (statusDiv.classList.contains(statusClass)) {
                         statusDiv.style.opacity = 0;
                         statusDiv.style.transform = 'translateY(-10px)';
                    }
                }, 7000);
            }
        }

        function updateEvaluationButton(isLoading, message = null) {
            const runButton = document.getElementById('run-eval-button');
            const buttonTextEl = document.getElementById('run-eval-button-text');
            const spinner = runButton?.querySelector('.loading-spinner');

            if (!runButton || !buttonTextEl || !spinner) {
                console.error("Evaluation button elements not found for update:", runButton, buttonTextEl, spinner);
                return;
            }

            runButton.disabled = isLoading;
            if (isLoading) {
                spinner.classList.remove('hidden');
                buttonTextEl.textContent = message || 'Vergleiche laufen...'; 
            } else {
                spinner.classList.add('hidden');
                buttonTextEl.textContent = `Starte ${COMPARISONS_PER_RUN_JS} Vergleiche`;
            }
        }

        function updateBarChart(selectedCategory) {
            console.debug(`Aktualisiere Balkendiagramm für: ${selectedCategory}`);
            const barCtx = document.getElementById('barChart')?.getContext('2d');
            const noDataElement = document.getElementById('bar-chart-no-data');
            if (!barCtx || !noDataElement) { console.error("Balkendiagramm Canvas oder no-data Element nicht gefunden."); return; }
            if (barChartInstance) barChartInstance.destroy();
            noDataElement.classList.add('hidden'); 

            const labels = [];
            const ratings = [];
            let chartTitle = `ELO Rating`;

            if (selectedCategory === ALL_CATEGORIES_KEY) {
                chartTitle = 'Durchschnitts-ELO über alle Kategorien';
                Object.entries(currentModelsData).forEach(([modelName, modelDetails]) => {
                    const categories = modelDetails.elo_rating_by_category || {};
                    let totalRating = 0;
                    let categoryCount = 0;
                    Object.values(categories).forEach(rating => {
                        if (typeof rating === 'number') {
                            totalRating += rating;
                            categoryCount++;
                        }
                    });
                    if (categoryCount > 0) {
                        labels.push(modelName);
                        ratings.push(totalRating / categoryCount);
                    }
                });
            } else {
                chartTitle = `ELO Rating (${capitalizeFirstLetter(selectedCategory)})`;
                Object.entries(currentModelsData).forEach(([modelName, modelDetails]) => {
                    const categoryRating = modelDetails.elo_rating_by_category?.[selectedCategory];
                    if (categoryRating !== undefined && typeof categoryRating === 'number') {
                        labels.push(modelName);
                        ratings.push(categoryRating);
                    }
                });
            }
            
            const sortedIndices = ratings.map((_, i) => i).sort((a, b) => ratings[b] - ratings[a]);
            const sortedLabels = sortedIndices.map(i => labels[i]);
            const sortedRatings = sortedIndices.map(i => ratings[i]);

            if (sortedLabels.length === 0) {
                console.warn(`Keine Daten für ${selectedCategory} im Balkendiagramm.`);
                noDataElement.textContent = selectedCategory === ALL_CATEGORIES_KEY ? 'Keine Modelldaten für Durchschnitts-ELO verfügbar.' : `Keine Daten für Kategorie ${capitalizeFirstLetter(selectedCategory)} verfügbar.`;
                noDataElement.classList.remove('hidden'); 
                barCtx.clearRect(0, 0, barCtx.canvas.width, barCtx.canvas.height);
                return;
            }

            const chartColors = generateColors(sortedLabels.length);
            const barBgColors = chartColors.map(color => color.fill); 
            const barBorderColors = chartColors.map(color => color.stroke); 

            barChartInstance = new Chart(barCtx, {
                type: 'bar',
                data: {
                    labels: sortedLabels,
                    datasets: [{
                        label: chartTitle,
                        data: sortedRatings,
                        backgroundColor: barBgColors,
                        borderColor: barBorderColors,
                        borderWidth: 1.5, 
                        borderRadius: 4, 
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                    scales: {
                        y: {
                            title: { display: true, text: 'Modell', font: { weight: '600' } },
                            ticks: { font: { size: 11 } }
                        },
                        x: {
                            beginAtZero: false, 
                            title: { display: true, text: 'ELO Rating', font: { weight: '600' } },
                            grid: { display: true, color: '#e5e7eb' } 
                        }
                    },
                    plugins: {
                        legend: { display: false }, 
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)', 
                            titleFont: { weight: 'bold' },
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label || ''}: ${ctx.parsed.x !== null ? ctx.parsed.x.toFixed(1) : 'N/A'}`
                            }
                        }
                    }
                }
            });
        }

        function updateRadarChart() {
            console.debug(`Aktualisiere Radardiagramm.`);
            const radarCtx = document.getElementById('radarChart')?.getContext('2d');
            const noDataElement = document.getElementById('radar-chart-no-data');
            if (!radarCtx || !noDataElement) { console.error("Radardiagramm Canvas oder no-data Element nicht gefunden."); return; }
            if (radarChartInstance) radarChartInstance.destroy();
            noDataElement.classList.add('hidden');

            const modelNames = Object.keys(currentModelsData).sort();
            const datasets = [];
            // Use availableCategories which is already sorted and contains unique categories
            const radarLabels = availableCategories.map(cat => capitalizeFirstLetter(cat));

            if (modelNames.length === 0 || radarLabels.length < 3) {
                 console.warn(`Nicht genug Daten für Radardiagramm (Modelle: ${modelNames.length}, Kategorien: ${radarLabels.length}).`);
                 noDataElement.classList.remove('hidden');
                 radarCtx.clearRect(0, 0, radarCtx.canvas.width, radarCtx.canvas.height);
                 return;
            }

            const radarChartColors = generateColors(modelNames.length);

            modelNames.forEach((modelName, index) => {
                const modelRatingsForCategories = [];
                let hasDataForModel = false;
                availableCategories.forEach(category => {
                    const rating = currentModelsData[modelName]?.elo_rating_by_category?.[category];
                    if (typeof rating === 'number') {
                        modelRatingsForCategories.push(rating);
                        hasDataForModel = true;
                    } else {
                        modelRatingsForCategories.push(null); 
                    }
                });

                if (hasDataForModel) {
                    datasets.push({
                        label: modelName.length > 20 ? modelName.substring(0,17) + '...' : modelName,
                        data: modelRatingsForCategories,
                        backgroundColor: radarChartColors[index % radarChartColors.length].fill, 
                        borderColor: radarChartColors[index % radarChartColors.length].stroke,   
                        pointBackgroundColor: radarChartColors[index % radarChartColors.length].stroke,
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: radarChartColors[index % radarChartColors.length].stroke,
                        borderWidth: 2,
                        pointRadius: 4, 
                        pointHoverRadius: 6
                    });
                }
            });

            if (datasets.length === 0) {
                 console.warn(`Keine Modelle mit Daten über die Kategorien gefunden für Radar-Diagramm.`);
                 noDataElement.classList.remove('hidden');
                 radarCtx.clearRect(0, 0, radarCtx.canvas.width, radarCtx.canvas.height);
                 return;
            }

            let allRatings = datasets.flatMap(ds => ds.data.filter(r => r !== null));
            const minRating = allRatings.length > 0 ? Math.min(...allRatings) : 1000;
            const maxRating = allRatings.length > 0 ? Math.max(...allRatings) : 2000;
            const scalePadding = Math.max(25, (maxRating - minRating) * 0.1); 

            radarChartInstance = new Chart(radarCtx, {
                type: 'radar',
                data: {
                    labels: radarLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: false,
                            angleLines: { display: true, color: '#d1d5db' }, 
                            suggestedMin: Math.floor(minRating - scalePadding / 2), 
                            suggestedMax: Math.ceil(maxRating + scalePadding / 2),
                            pointLabels: { font: { size: 12, weight: '500' }, color: '#374151' }, 
                            ticks: {
                                backdropColor: 'rgba(255, 255, 255, 0.85)',
                                stepSize: 50, 
                                font: { size: 10 }
                            },
                            grid: { color: '#e5e7eb' } 
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom', 
                            labels: { boxWidth: 12, padding: 15, font: { size: 11 } }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleFont: { weight: 'bold' },
                            callbacks: {
                                title: (tooltipItems) => tooltipItems.length > 0 ? tooltipItems[0].dataset.label : '',
                                label: (context) => {
                                    let label = context.chart.data.labels[context.dataIndex] || '';
                                    if (label) label += ': ';
                                    label += context.parsed.r !== null ? context.parsed.r.toFixed(1) : 'N/A';
                                    return label;
                                }
                            }
                        }
                    },
                    elements: { line: { tension: 0.1 } } 
                }
            });
        }

        function populateOverallRankings(modelsData) {
            const tableBody = document.getElementById('overall-rankings-table-body');
            if (!tableBody) return;
            tableBody.innerHTML = '';
            const modelStats = [];

            Object.entries(modelsData).forEach(([modelName, modelDetails]) => {
                const categories = modelDetails.elo_rating_by_category || {};
                let highestRating = -Infinity;
                let highestCategory = 'N/A';
                let totalRating = 0;
                let categoryCount = 0;

                if (Object.keys(categories).length > 0) {
                    Object.entries(categories).forEach(([cat, rating]) => {
                        if (typeof rating === 'number') {
                            if (rating > highestRating) { highestRating = rating; highestCategory = cat; }
                            totalRating += rating;
                            categoryCount++;
                        }
                    });
                }
                const avgRating = categoryCount > 0 ? totalRating / categoryCount : 0;
                
                modelStats.push({
                    name: modelName,
                    highestCategory: highestCategory,
                    highestRating: highestRating === -Infinity ? 0 : highestRating, // Handle case with no ratings
                    avgRating: avgRating,
                    categoryCount: categoryCount,
                    num_comparisons: modelDetails.num_comparisons ?? 0,
                    wins: modelDetails.wins ?? 0,
                    losses: modelDetails.losses ?? 0,
                    draws: modelDetails.draws ?? 0
                });
            });

            modelStats.sort((a, b) => b.avgRating - a.avgRating);

            if (modelStats.length === 0) {
                // Updated colspan to 9 for the new columns
                tableBody.innerHTML = '<tr><td colspan="9" class="px-6 py-4 text-sm text-slate-500 text-center">Keine Modelle mit Ratings gefunden. Starte Vergleiche.</td></tr>';
                return;
            }

            modelStats.forEach((stats, index) => {
                const highestRatingDisplay = stats.highestRating === 0 && stats.categoryCount === 0 ? 'N/A' : stats.highestRating.toFixed(1);
                const avgRatingDisplay = stats.avgRating === 0 && stats.categoryCount === 0 ? 'N/A' : stats.avgRating.toFixed(1);

                const row = `
                <tr class="hover:bg-slate-50 transition-colors duration-150">
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold ${index < 3 ? 'text-blue-600' : 'text-slate-800'}">${index + 1}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-slate-800">${stats.name}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">${stats.categoryCount > 0 ? capitalizeFirstLetter(stats.highestCategory) : 'N/A'}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600 font-medium">${highestRatingDisplay}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600 font-medium">${avgRatingDisplay} <span class="text-xs text-slate-400">(${stats.categoryCount} Kat.)</span></td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">${stats.num_comparisons}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-green-600 font-medium">${stats.wins}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-red-600 font-medium">${stats.losses}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">${stats.draws}</td>
                </tr>`;
                tableBody.innerHTML += row;
            });
        }

        function populateDetailedTable(modelsData, categories) {
            const tableHead = document.getElementById('detailed-ratings-thead');
            const tableBody = document.getElementById('detailed-ratings-tbody');
            if (!tableHead || !tableBody) return;

            tableHead.innerHTML = '';
            let headerHtml = '<tr><th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Modell</th>';
            if (categories.length === 0) {
                 headerHtml += '<th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">Keine Kategorien</th>';
            } else {
                categories.forEach(cat => {
                    headerHtml += `<th scope="col" class="px-6 py-4 text-left text-xs font-semibold text-slate-600 uppercase tracking-wider">${capitalizeFirstLetter(cat)}</th>`;
                });
            }
            headerHtml += '</tr>';
            tableHead.innerHTML = headerHtml;

            tableBody.innerHTML = '';
            const modelNames = Object.keys(modelsData).sort();

            if (modelNames.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="${categories.length + 1}" class="text-center py-6 text-slate-500">Keine Modelldaten verfügbar.</td></tr>`;
                return;
            }

            modelNames.forEach(modelName => {
                const modelDetails = modelsData[modelName];
                const categoryRatings = modelDetails.elo_rating_by_category || {};
                const comparisonCounts = modelDetails.comparison_counts_by_category || {};

                let rowHtml = `<tr class="hover:bg-slate-50 transition-colors duration-150"><td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-slate-800">${modelName}</td>`;
                if (categories.length === 0) {
                     rowHtml += '<td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">N/A</td>';
                } else {
                    categories.forEach(cat => {
                        const rating = categoryRatings[cat];
                        const displayRating = (typeof rating === 'number') ? rating.toFixed(1) : '<span class="text-slate-400">N/A</span>';
                        
                        const catStats = comparisonCounts[cat];
                        let tooltipText = 'Keine Vergleichsdaten';
                        if (catStats) {
                            tooltipText = `S: ${catStats.wins ?? 0}, N: ${catStats.losses ?? 0}, U: ${catStats.draws ?? 0} (${catStats.num_comparisons ?? 0} Vergl.)`;
                        }
                        
                        rowHtml += `<td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600" title="${tooltipText}">${displayRating}</td>`;
                    });
                }
                rowHtml += '</tr>';
                tableBody.innerHTML += rowHtml;
            });
             if (tableBody.innerHTML === '') {
                 tableBody.innerHTML = `<tr><td colspan="${categories.length + 1}" class="text-center py-6 text-slate-500">Keine detaillierten Ratings verfügbar.</td></tr>`;
            }
        }

        function populateCategoryDropdowns(categories) {
            const selectBar = document.getElementById('category-select-bar');
            if (!selectBar) return;

            const currentBarValue = selectBar.value;
            selectBar.innerHTML = '';

            if (categories.length === 0 && Object.keys(currentModelsData).length === 0) { 
                selectBar.innerHTML = '<option value="">Keine Kategorien</option>';
                selectBar.disabled = true;
            } else {
                selectBar.disabled = false;
                const allOption = document.createElement('option');
                allOption.value = ALL_CATEGORIES_KEY;
                allOption.textContent = 'Alle Kategorien (Durchschnitt)';
                selectBar.appendChild(allOption);

                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = capitalizeFirstLetter(category);
                    selectBar.appendChild(option);
                });
                
                if (currentBarValue && (categories.includes(currentBarValue) || currentBarValue === ALL_CATEGORIES_KEY)) {
                    selectBar.value = currentBarValue;
                } else {
                     selectBar.value = ALL_CATEGORIES_KEY; 
                }
            }
        }

        function updateDashboard(data) {
            console.log("updateDashboard called with data:", data);
            const dashboardContent = document.getElementById('dashboard-content');
            const loadingIndicator = document.getElementById('loading-indicator');
             if (!data || !data.models) {
                 console.error("Ungültige Datenstruktur für updateDashboard:", data);
                 if (loadingIndicator) loadingIndicator.innerHTML = '<p class="text-red-600 font-semibold">Fehler beim Empfangen der Daten.</p>';
                 if (dashboardContent) dashboardContent.classList.add('hidden');
                 return;
             }

            currentModelsData = data.models;
            currentTimestamp = data.timestamp;
            const dataTimestampEl = document.getElementById('data-timestamp');
            if (dataTimestampEl) dataTimestampEl.textContent = formatTimestamp(currentTimestamp);

            const categories = new Set();
            Object.values(currentModelsData).forEach(details => {
                Object.keys(details.elo_rating_by_category || {}).forEach(cat => categories.add(cat));
            });
            availableCategories = Array.from(categories).sort();
            console.log("Available categories:", availableCategories);

            populateCategoryDropdowns(availableCategories); 

            if (Object.keys(currentModelsData).length === 0) {
                console.warn("Keine Modelldaten in den Ergebnissen.");
                const overallRankingsBody = document.getElementById('overall-rankings-table-body');
                // Updated colspan to 9
                if (overallRankingsBody) overallRankingsBody.innerHTML = '<tr><td colspan="9" class="px-6 py-4 text-sm text-slate-500 text-center">Keine Modelldaten verfügbar. Starte Vergleiche.</td></tr>';
                populateDetailedTable({}, []);
                if (barChartInstance) barChartInstance.destroy();
                if (radarChartInstance) radarChartInstance.destroy();
                const barNoData = document.getElementById('bar-chart-no-data');
                const radarNoData = document.getElementById('radar-chart-no-data');
                if(barNoData) barNoData.classList.remove('hidden');
                if(radarNoData) radarNoData.classList.remove('hidden');
            } else {
                populateOverallRankings(currentModelsData);
                populateDetailedTable(currentModelsData, availableCategories);
                
                const categorySelectBar = document.getElementById('category-select-bar');
                const selectedCategoryForBarChart = categorySelectBar?.value || ALL_CATEGORIES_KEY;

                updateBarChart(selectedCategoryForBarChart); 
                updateRadarChart(); 
            }

            if (loadingIndicator) loadingIndicator.classList.add('hidden');
            if (dashboardContent) dashboardContent.classList.remove('hidden');
            console.log("Dashboard updated.");
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired.");
            const loadingIndicator = document.getElementById('loading-indicator');
            const dashboardContent = document.getElementById('dashboard-content');
            const runButton = document.getElementById('run-eval-button');
            const categorySelectBar = document.getElementById('category-select-bar');

            try {
                console.log("Attempting initial data fetch and setup...");
                fetch(API_INITIAL_RESULTS_URL)
                    .then(response => {
                        console.log("Initial /api/results response received, status:", response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP Fehler! Status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("Initiale Daten geladen:", data);
                        updateDashboard(data);
                    })
                    .catch(error => {
                        console.error('Fehler beim initialen Laden der Dashboard-Daten:', error);
                        if (loadingIndicator) loadingIndicator.innerHTML = '<p class="text-red-600 font-semibold">Fehler beim Laden der initialen Daten. Prüfe die Konsole.</p>';
                        if (dashboardContent) dashboardContent.classList.add('hidden');
                        fetchEvaluationStatus();
                        connectEventSource();
                    })
                    .finally(() => { 
                        console.log("Initial data fetch process completed (finally block).");
                        if (!document.querySelector('#loading-indicator p.text-red-600')) { 
                             fetchEvaluationStatus();
                             connectEventSource();
                        }
                    });

                if (runButton) {
                    console.log("Run evaluation button found. Adding click listener.");
                    runButton.addEventListener('click', runEvaluation);
                } else {
                    console.error("Run evaluation button (run-eval-button) NOT found!");
                }

                if (categorySelectBar) {
                    console.log("Category select (bar chart) found. Adding change listener.");
                    categorySelectBar.addEventListener('change', (event) => {
                        updateBarChart(event.target.value);
                    });
                } else {
                    console.warn("Category select for bar chart (category-select-bar) NOT found!");
                }

            } catch (e) {
                console.error("Error during DOMContentLoaded setup:", e);
                if (loadingIndicator) loadingIndicator.innerHTML = '<p class="text-red-500">Ein kritischer JavaScript-Fehler ist aufgetreten. Prüfe die Konsole.</p>';
            }
        });

        function connectEventSource() {
            try {
                if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
                    console.log("SSE connection already open or connecting. Closing existing one.");
                    eventSource.close();
                }
                console.log("Connecting to SSE Stream:", API_RESULTS_STREAM_URL);
                eventSource = new EventSource(API_RESULTS_STREAM_URL);

                eventSource.onopen = function() {
                     console.log("SSE Verbindung geöffnet.");
                     const statusDiv = document.getElementById('eval-status');
                     if (statusDiv && statusDiv.classList.contains('status-warning') && statusDiv.textContent.includes("Verbindung")) {
                         fetchEvaluationStatus();
                     }
                };

                eventSource.onmessage = function(event) {
                    console.log("SSE Nachricht empfangen:", event.data);
                    try {
                        const data = JSON.parse(event.data);
                        updateDashboard(data);
                    } catch (e) {
                        console.error("Fehler beim Parsen der SSE Daten:", e, "Daten:", event.data);
                    }
                };

                eventSource.onerror = function(err) {
                    console.error("EventSource Fehler:", err);
                    showStatusMessage("Verbindung zum Server verloren. Versuche erneuten Verbindungsaufbau...", "warning", true);
                    if (eventSource) eventSource.close();
                    setTimeout(connectEventSource, 7000); 
                };
            } catch (e) {
                console.error("Error in connectEventSource:", e);
            }
        }

        async function fetchEvaluationStatus() {
            console.log("Fetching evaluation status...");
            try {
                const response = await fetch(API_EVAL_STATUS_URL);
                console.log("/api/evaluation_status response status:", response.status);
                if (!response.ok) {
                    let errorText = `HTTP Fehler! Status: ${response.status}`;
                    try {
                        const errorJson = await response.json();
                        errorText = errorJson.message || errorJson.error || errorText;
                    } catch (e) { /* ignore parsing error */ }
                    throw new Error(errorText);
                }
                const statusData = await response.json();
                console.log("Evaluationsstatus data:", statusData);
                updateEvaluationButton(statusData.running, statusData.message);
                const isSticky = statusData.running || statusData.status === 'error';
                showStatusMessage(statusData.message, statusData.status || 'info', isSticky);
            } catch (error) {
                console.error('Fehler beim Abrufen des Evaluationsstatus:', error);
                showStatusMessage(`Fehler beim Statusabruf: ${error.message}`, "error", true); 
                updateEvaluationButton(false); 
            }
        }

        async function runEvaluation() {
            console.log("runEvaluation called.");
            updateEvaluationButton(true, "Starte Evaluation...");
            showStatusMessage("Sende Anfrage zum Starten der Evaluation...", "loading", true);
            try {
                const response = await fetch(API_RUN_EVAL_URL, { method: 'POST' });
                console.log("/api/run_evaluation response status:", response.status);

                const responseText = await response.text();
                console.log("/api/run_evaluation response text:", responseText);
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    if (response.ok) {
                        console.warn("Response from /api/run_evaluation was not JSON but status was OK:", responseText);
                        showStatusMessage(responseText || "Evaluation gestartet (unerwartete Antwort).", "info", true);
                        updateEvaluationButton(true, responseText || "Läuft..."); 
                        setTimeout(fetchEvaluationStatus, 2000); 
                        return;
                    } else {
                        throw new Error(`Serverfehler: ${response.status} - ${responseText}`);
                    }
                }

                if (!response.ok) {
                     let errorMsg = result.error || result.message || `HTTP Fehler! Status: ${response.status}`;
                     showStatusMessage(errorMsg, result.status || 'error', result.running || true); 
                    throw new Error(errorMsg);
                }

                console.log("Evaluationsstart Antwort:", result);
                updateEvaluationButton(result.running, result.message);
                showStatusMessage(result.message, result.status || 'info', result.running);
                if (result.running && (!eventSource || eventSource.readyState === EventSource.CLOSED)) {
                    connectEventSource();
                }

            } catch (error) {
                console.error('Fehler beim Starten der Evaluation:', error);
                showStatusMessage(`Fehler beim Starten: ${error.message}`, "error", true); 
                updateEvaluationButton(false);
                setTimeout(fetchEvaluationStatus, 1000); 
            }
        }
        console.log("Script block finished parsing.");
    </script>
</body>
</html>
